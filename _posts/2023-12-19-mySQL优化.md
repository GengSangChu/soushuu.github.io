---
layout:     post
title:      mySQL优化
subtitle:   mySQL查询优化
date:       2023-12-19
author:     soushuuu
header-img: img/the-first.png
catalog: false
tags:
    - mySQL
---

SQL优化三个底层逻辑：

* 不要让查询优化器为难，查询优化器的作用是根据SQL语句匹配最为合适的索引，生成执行计划。最常见的一种场景是给索引字段加函数或计算，索引存储的都是原值，没有一颗索引树存储的是计算后的结果，索引不会用到索引。而且一些复杂的子查询也会让查询优化器无法识别，导致索引效果不理想。所以计量不要在索引字段使用函数、计算、is null，语句尽量简单。
* 尽量短的寻址路程。尽量走索引，尽量减少回表。合适使用联合索引，尽量让索引树覆盖需要查询的所有字段，把非聚集索引做成聚集索引。
* 尽量减少IO。数据库查询本质是对磁盘的检索，这个过程需要将数据从硬盘加载到内存，查询数量越多，则必然查询速度越慢。能分批尽量分批。

（PS：很多时候SQL是没办法优化的，所以才出现其他解决方案，如大数据技术，用空间换时间，用分布式计算解决数据处理问题）

## 索引原理

### 索引概述

MySQL官方对索引定义：索引是MySQL存储引擎用于快速查找记录的一种数据结构。
简单理解为： 索引是 排好序的数据结构，帮助我们快速的查询数据库表中的数据。
索引是一个独立的、物理的数据结构，它是由一个表中的一个字段或者多个字段的值组合成的集合。
MySQL中，默认使用的是B+Tree结构管理索引。

### B-Tree

![B-Tree]({{site.baseurl}}/img/mysql/B-Tree.png)

### B+ Tree

![B+ Tree]({{site.baseurl}}/img/mysql/B+Tree.png)
![B+ Tree]({{site.baseurl}}/img/mysql/B+Tree2.png)

B树和B+树的最大区别是，B树每个节点下都存储数据，而B+树则将数据存储在叶子节点，并且每个节点间使用双向链表进行关联。这也导致了B树的每一层存储的key减少，进而存储层数变高。但是如果把热点数据放到靠近根节点部分存储，则可加快热点数据的查询效率。
B+树因为将数据存储在叶子节点，所以每一层都能容纳更多的key，进而减少树的层数，减少IO次数。并且每个节点间使用双联链表关联，所以很适合进行范围查询。

在B+树中，一个节点的大小是一个数据页，在InnoDB中，最小存储单元就是页。这样，每个节点只需要一次IO就能加载一个完整的页的数据。

##### B+树数据查找方式

* 跟B-Tree一样，通过指针实现随机查找，从根节点开始。
* 根据叶子节节点进行顺序查找，在一个节点的内部可以实现折半查找，在多个节点之间，因为是通过指针连接的，所以要使用顺序查找。


### 哈希索引

*  Hash索引底层是由Hash表实现的，是根据键值<key，value>存储数据。 
*  Hash索引非常适合 根据Key查找value值，也就是单个key的查询或者说等值查询。 

##### 应用场景

* 哈希索引主要用在 memory 引擎
* InnoDB 引擎不支持 哈希索引


### 聚簇索引

##### 索引分类

* 按照字段的特性分类：主键索引、普通索引、前缀索引。
* 按照数据结构分类： B+Tree索引、Hash索引。
* 按照物理存储方式分类：聚簇索引、辅助索引（二级索引）。

    聚簇索引并不是一种单独的索引类型，聚簇索引是一种数据存储的方式。例如InnoDB的聚簇索引使用的数据结构就是B+Tree存储索引和数据。
    “聚簇” 含义：表示数据行和相邻的键值是紧凑的存储在一起。
    辅助索引（二级索引）：叶子节点是不会保存引用行的物理地址的，而是保存行的主键值。

在Innodb中，聚簇索引一般就是指的主键索引，如果没有主键，Innodb会默认给表创建一个隐藏主键。辅助索引则是指其他字段的索引，在这些索引的节点中存储的是主键id和索引值，所以如果需要查询的数据没有在辅助索引上，则需要回表，即回到主键索引中进行查询。

##### 索引下推

索引下推：MySQL5.6引入的，用于查询优化。可以在索引遍历的过程中，对索引中包含的字段先做判断，不符合条件的记录过滤，作用就是减少回表的次数。 


### Explain

explain用于sql的查询性能分析。各个字段的功能如下：

~~~

id
    操作表顺序

select_type
    每个 select 子句类型
        SIMPLE
            查询不包含子查询或UNION
        PRIMARY
            包含子查询，最外是PRIMARY
        SUBQUERY
            包含子查询，子查询标记为 SUBQUERY
        DERIVED
            在 FROM 中包含子查询，被标记为 DERIVED
        UNION
            第二个 SELECT 出现在 UNION 后
        UNION RESULT
            从 UNION 表获取结果

table
    操作表

partitions
    当前查询匹配记录的分区。对于未分区的表，返回null

type
    访问类型
        ALL
            无索引全表扫描
        INDEX
            有索引全表扫描
        RANGE
            索引范围扫描
        REF
            非唯一性索引扫描
        EQ_REF
            唯一性索引扫描
        CONST, SYSTEM
            where 常量查询
        NULL
            无表访问

    连接类型，有如下几种取值，性能从好到坏排序 如下：
        system：该表只有一行（相当于系统表），system是const类型的特例
        const：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可
        eq_ref：当使用了索引的全部组成部分，并且索引是PRIMARY KEY或UNIQUE NOT NULL 才会使用该类型，性能仅次于system及const。
        ref：当满足索引的最左前缀规则，或者索引不是主键也不是唯一索引时才会发生。如果使用的索引只会匹配到少量的行，性能也是不错的。
        fulltext：全文索引
        ref_or_null：该类型类似于ref，但是MySQL会额外搜索哪些行包含了NULL。这种类型常见于解析子查询
        index_merge：此类型表示使用了索引合并优化，表示一个查询里面用到了多个索引
        unique_subquery：该类型和eq_ref类似，但是使用了IN查询，且子查询是主键或者唯一索引。
        index_subquery：和unique_subquery类似，只是子查询使用的是非唯一索引
        range：范围扫描，表示检索了指定范围的行，主要用于有限制的索引扫描。比较常见的范围扫描是带有BETWEEN子句或WHERE子句里有>、>=、<、<=、IS NULL、<=>、BETWEEN、LIKE、IN()等操作符。
        index：全索引扫描，和ALL类似，只不过index是全盘扫描了索引的数据。当查询仅使用索引中的一部分列时，可使用此类型。
        ALL：全表扫描，性能最差。

        index 有两种场景会触发：
            如果索引是查询的覆盖索引，并且索引查询的数据就可以满足查询中所需的所有数据，则只扫描索引树。此时，explain的Extra 列的结果是Using index。index通常比ALL快，因为索引的大小通常小于表数据。
            按索引的顺序来查找数据行，执行了全表扫描。此时，explain的Extra列的结果不会出现Uses index。

possible_keys
    展示当前查询可以使用哪些索引，这一列的数据是在优化过程的早期创建的，因此有些索引可能对于后续优化过程是没用的。

key
    实际使用的索引

key_len
    索引使用的字节数。由于存储格式，当字段允许为NULL时，key_len比不允许为空时大1字节。

ref
    被使用的索引具体字段（索引的那一列被引用了），表示将哪个字段或常量和key列所使用的字段进行比较。
    
rows
    命中行统计, MySQL估算会扫描的行数，数值越小越好。

filtered
    符合查询条件的数据百分比，表示符合查询条件的数据百分比，最大100。用rows × filtered可获得和下一张表连接的行数。例如rows = 1000，filtered = 50%，则和下一张表连接的行数是500。

Extra
    附加信息

~~~


### 高性能索引的创建及使用策略

* 索引列的类型尽量小
* 索引列的选择性尽量高 选择性 = 不同值的数据量 / 总行数
* 前缀索引的使用
    前缀索引的`缺点`：前缀索引是一种能使索引更小，更快的有效办法，但是它的缺点也很明显，MySQL中无法使用前缀索引做order by 、group by ,也无法使用前缀索引进行索引覆盖。 
    前缀索引使用的`注意事项`：使用的是较短的前缀，可能会降低索引的选择性，影响查询效率。所以在使用前缀索引之前，需要仔细考虑分析数据分布，确保前缀长度的选择是合适。 
* 多列索引
    多列索引的创建原则
    选择性最高的列放在最前面，因为选择性高的列通常可以更好的筛选数据，减少检索的数据量。
    根据运行频率最高的查询，来调整索引列的顺序。
    覆盖查询需要的列，创建联合索引的时候，要注意这个联合索引是否是一个覆盖索引。可以避免在索引中和表中来回的跳转（回表）。
    避免冗余索引： 如果已经有了一个联合索引，再创建一个包含该索引一部分的索引是没有必要的。冗余索引会增加索引的维护成本。
    权衡索引的长度：太长索引会占用更多的存储空间，同时也会降低索引检索效率。
    避免使用过多列：只去选择那些在查询中被经常使用到的列。
    只对在查询条件中被经常使用、或者排序分组中经常使用的 字段，去创建索引。
* 三星索引
    三星索引需要`满足的条件`：
    索引将相关的记录放到了一起， 获得一星。
    如果索引中的数据顺序和查找中的排序顺序是一致的，就获得第二颗星（排序星）。
    如果索引中包含了所要查询的全部列的数据，就会获得三星（宽索引星）。
* 最佳左前缀法则
    `最佳左前缀法则`：使用索引时，where后面的条件需要从索引的最左前列开始，并且不能够跳过索引 中的列使用。创建的是联合索引，在使用时要遵守该法则。
    MYSQL在`创建联合索引时的规则`是：首先会对联合索引最左边的字段进行排序，在第一个字段的基础之上，再对第二个字段进行排序。
* 不要做索引列上做任何操作
    不要在索引列上做任何操作，包括了比如计算、使用函数、自动的或者手动进行数据类型转换，都会导致索引的失效，从而使查询转向全表扫描。
* 范围条件放最后
    在编写查询语句的时候，where条件中如果有范围条件，并且范围条件之后还有其他过滤条件的话，那么范围条件之后的列就都将会索引失效。
* like查询以%开头的话，就会使索引失效，%出现在左边索引失效，%出现在右边索引正常使用。
* 避免使用 is null、is not null 、!= 、or
    1）定义1： null值代表着一个未确定的值，MySQL认为任何和null值进行比较的表达式的结果都为null。所以认为每一个null值都是独一无二。
    2）定义2：null值在业务上就是代表没有，所有的null 就被算作是一份。
    3） 定义3：null值完全没有意义，在统计的时候就不要算进来了。


### 慢查询日志分析

![mysql调优金字塔]({{site.baseurl}}/img/mysql/mysql调优金字塔.png)

硬件和OS的调优，十分复杂，需要有对硬件和OS了解比较深的人员去进行化。
MySQL调优,调整表结构、优化SQL、恰当的使用索引，清除多余的索引等等。
架构调优，需要考虑实际的业务场景 

    可以将非数据库的任务，放到数据仓库，搜索引擎或者缓存。
    评估并发量，决定是不是要做分布式。
    根据读压力，考虑是否进行读写分离。

##### 什么是慢查询日志

    记录查询话费大量时间的SQL的日志，就是慢查询日志。
    long_query_time采数：该参数会设定一个阈值，超过该值的SQL，就是慢查询SQL。

查询性能变低的最基础的原因，就是访问的数据太多了。
对于低效的查询，可以通过下面两个步骤分析：

    确认是否在检索大量超过需要的数据。可能是访问了很多的行，也有可能是访问了很多的列。
    确认MySQL服务层是否在分析大量超过需要的数据行。


### JOIN优化

JOIN操作有几种方式：
* 左连接
    -- left join 左连接,查询出左表的全部数据，以及右表相匹配的数据，不存在的用空表示
* 右连接
    -- right join 右外连接,查询出右表的全部数据，以及左表相匹配的数据，不存在的用空表示
* 内连接
    -- inner join，只获取两张表有交集的数据。

#### 驱动表和被驱动表

什么是驱动表？

* 多表关联查询的时候，第一个被处理的表就是驱动表，使用驱动表关联其他表。
* 驱动表的确定是非常关键的，会直接影响到多表关联的顺序，还有决定了后续的关联查询的性能。

1）连接查询没有where条件的时候：

    -- 右外连接，驱动表的选择：后面的表示驱动表，前面是被驱动表
    -- 内连接，驱动表的选择：谁的数据少，谁就是驱动表

2）连接查询存在where条件：

    带where条件的表就是驱动表，否则是被驱动表

3）驱动表选择的原则：在对最终的结果集没有影响的情况下，优先选择结果集小的那张表作为驱动表。

#### JOIN算法原理

##### Simple Nested Loop JOIN 简单嵌套循环连接

    简单嵌套循环连接就是一个 双层for循环，通过循环外层表的行数据，逐个与内层表的行数据进行比较来获取结果。

##### Index Nested Loop join 索引嵌套循环连接

    与SNL的区别：减少了内层表的数据的匹配次数，主要是因为在join字段（指的是被驱动表中的用于连接的字段）上建立了索引。
    注意：使用 Index Nested loop join算法，前提是 被驱动表的匹配字段，必须建立索引。

##### Block Nested Loop Join 块嵌套循环连接

    在没有使用到索引字段进行表连接的时候，MYSQL会选择使用BNL 块嵌套循环连接，通过加入buffer缓冲区，降低内循环的次数。

##### JOIN使用总结：

    永远用小的结果集去驱动大的结果集（本质就是减少外层循环的数据数量）。
    应该为匹配的条件 增加索引（减少内层表的循环匹配次数）。
    增加 join buffer的大小（一次缓存的越多，内层表扫描的次数就越少）
    减少不必要的字段查询（字段越少，join buffe所缓存的数据就越多)。

##### in和exists函数

    如果子查询的结果集比较小，主查询的表中数据比较大而且有索引时，应该优先选择in函数。

    exists 是一个用于判断子查询是否返回结果的条件函数，返回值是boolean类型。通常使用的场景是判断一个子查询是否至少返回一行数据，根据判断结果进行相应操作。


#### order by与group by优化

##### order by

    MySQL中有两种排序方式：
        索引排序：通过有序索引进行顺序扫描，直接返回有序的数据。
        额外排序：对返回的数据进行文件排序
    order by 优化的核心原则： 尽量减少额外排序，通过索引直接返回有序数据。

##### group by

    group by一般用于分组统计

    问题1：group by 一定要配合聚合函数吗？
    分组就是要去做统计的，否则分组没有意义了，所以一般都要配合聚合函数去使用，比如：count、sum、avg...

    问题2：group by 后面跟的字段，一定要出现在select列表中吗？
    答： 是一定要出现。如果没有没法确定是哪一个分组的值了。在标准SQL规范中，这点是必须的。（MySQL中大部分版本没有强制规定，Oracle中强制规定的），编写SQL时尽量在select列表中列出分组字段，确保查询的可移植性和可读性。

    问题3：where和having的区别？
    having 子句用于分组后的筛选，where子句用于行条件的筛选。
    having 都是配合分组和聚合函数一起出现。
    where子句中不能使用聚合函数，但是having可以。

###### group by优化方案

    优化方案1：group by 默认要进行排序，在合适的场景下，取消这个默认排序。

    优化方案2：为group by字段添加索引，让其一开始的时候就是有序的。

    优化方案3：尽量使用内存表
    如果group  by需要统计的数据不多，可以尽量使用内存临时表，因为如果内存放不下，就会下沉到磁盘临时表中，导致性能下降。

    优化方案4：使用SQL_BIG_RESULT优化
    如果数据量特别大，数据就算放到临时表中（临时表已经够大了），但是还是会因为数据的插入达到上限，再转成磁盘临时表，还是会影响到数据库的性能。
    如果预数据量比较大，我们使用SQL_BIG_RESULT直接提示MySQL 直接磁盘临时表。
        一旦添加了SQL_BIG_RESULT，MySQL就不会再用B+树结构存储临时表数据，存储效率低，会选择使用数组，直接用数组存储。


#### MySQL查询成本计算

    在MySQL中，一条查询语句的执行成本实际上是由两部分构成的：
    I/O 成本
        MyISAM 和 InnoDB都需要将数据和索引存储到磁盘，当进行查询时，就需要把数据或者索引加载到内存中。从磁盘到内存这个加载过程，损耗的时间，我们称之为 I/O 成本
    CPU成本
        读取记录的时候，需要检测记录是否满足对应的 搜索条件、对结果集进行排序等等操作发生的损耗都称之为 CPU成本。
    成本常数
        I/O成本常数：1.0 ，MySQL规定读取一个页面花费的成本默认是1.0
        CPU成本常数：0.2，读取以及检测一条记录是否符合搜索条件的成本，默认是0.2

###### MySQL中找出成本最低方案的过程，大致如下

1. 根据搜索条件，找出所有可能使用的索引。
2. 计算全表扫描的代价。
3. 计算使用不同索引，执行查询的代价。
4. 对比各种执行方案的代价，找出成本最低的那个。