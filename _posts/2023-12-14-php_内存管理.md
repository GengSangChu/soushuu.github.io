---
layout:     post
title:      PHP 内存管理
subtitle:   内存管理
date:       2023-12-14
author:     soushuuu
header-img: img/the-first.png
catalog: false
tags:
    - PHP
---

关于内存管理，其实就是对堆内存的管理，因为栈上的内存是随着变量的生命周期被自动创建与释放的。

而堆中的数据则是通过另一种方式进行创建与释放，这就产生了对这部分内存的管理机制的需求。

在对这部分内存管理中，有如C、C++的手动申请与释放（C++也有通过智能指针进行自动释放）；也有如PHP的，手动申请，通过引用计数方式来释放；亦有如Java、go，手动申请，通过后台GC线程自动进行内存的整理与释放；还有如rust，通过变量所有权来进行内存的释放。

现在看一下PHP的引用计数GC机制。

从[PHP的数据类型]({{site.baseurl}}/2023/12/13/php的数据类型/)中可以看到，每种变量类型都有一个 gc 成员，这个就是用于他们的引用计数。

###写时复制
使用引用计数，则会出现不同的变量引用同一个 zend_value ，当变量修改后，就需要对 zend_value 进行分离，即发生修改的变量会复制一份新的 value 出来进行修改，而会断开与之前的 value 的指向，从而实现变量修改。

但实际上并不是所有 value 都可以进行分离，只有数组类型支持。

###垃圾回收
如果通过引用计数进行GC，那么，每当 value 引用计数降为 0 ，判断一下不就可以自动释放了吗？但实际上，引用计数无法解决的一个问题是，变量之间存在循环引用问题。
如
```php
$a = [];
$a[] = &$a;
unset($a);
```
$a 这一变量内部成员引用了 $a 自身。当 unset($a) 后，$a 没有了外部引用，但是数组的引用计数仍然大于0，无法释放。
因为这种循环引用导致的无法释放的变量称为垃圾，PHP引入一个垃圾回收器来进行这些垃圾的回收。

在此明确两个准则：
* 如果一个变量 value 的 refcount 减少到 0 ，那么此 value 可以被释放，不属于垃圾。
* 如果一个变量 value 的 refcount 减少之后大于 0 ，那么此 value 不能被释放，可能成为一个垃圾。

垃圾回收器会将第二种情况的变量收集起来，等到达一定数量后，垃圾回收器会启动鉴定程序，把真正的垃圾释放掉。

目前垃圾只在 array、object 两种类型中出现，PHP 使用 IS_TYPE_COLLECTABLE 宏来标记他们，这个宏在 zval.u1.v.type_flags 中使用。

回收算法额回收过程如下，具体实现以后再讨论。

    1. 遍历垃圾回收器的 buffer 缓冲区，把当前的 value 标记为灰色，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 refcount 减 1，并且也标记为灰色。
    2. 重复遍历 buffer ，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标记为白色，如果不为 0 ，则排除了引用全部来自自身成员的可能，表示还有外部引用，不是垃圾，这时因为在步骤1中对成员进行了 refcount - 1 操作，需要再次还原回去，于是对所有成员进行深度优先遍历，把 1 加回去，同时标记为黑色。
    3. 再次遍历 buffer ，将不是标记为白色的节点从buffer中删除，然后将被标记为白色的这些垃圾释放，回收完成。

## 内存池

内存池有不同实现，如 tcmalloc、ptmalloc、jemalloc等。

简单看下 PHP 的内存池，具体实现以后讨论。


PHP 内存池定义了三种粒度内存块：chunk、page、slot，每个 chunk 大小为 2MB，page 大小为4KB，一个chunk被切割为512个page，而一个或若干个page被切割为多个slot。

申请内存时按照不同的申请大小决定具体分配策略。
* Huge(chunk)：申请内存大于 2044KB，直接调用系统分配，分配若干个 chunk。
* Large(page)：申请内存大于3092B（即page的3/4大小），小于2044KB（即511个page），分配若干个page。
* Small(slot)：申请内存小于等于3092B（即page大小的3/4），内存池提前定义好了30种同等大小的内存（8,16,24,32,...,3072），它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应page上查找可用的slot。