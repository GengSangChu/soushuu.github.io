---
layout:     post
title:      rust入门
subtitle:   rust入门
date:       2024-01-11
author:     soushuuu
header-img: img/the-first.png
catalog: false
tags:
    - rust
---

`标准库文档：https://doc.rust-lang.org/std/index.html`

### 变量、常量

- 可变性
- 常量
- 隐藏


### 数据类型

#### 标量类型

- 整型
    - i8、u8
    - i16、u16
    - i32、u32
    - i64、u64
    - i128、u128
    - isize、usize
        - isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。
- 浮点型
    - f32、f64
- 布尔型
    - true、false
- 字符
    - char

#### 复合类型

- 元组（tuple）
- 数组（array）


### 函数

在函数签名中，必须声明每个参数的类型。



#### 语句和表达式

语句（Statements）是执行一些操作但不返回值的指令。
表达式（Expressions）计算并产生一个值。



### 注释

- 注释、文档注释


### 控制流

- if
- loop、while、for



### 所有权

所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。__Rust__ 则选择了第三种方式：__通过所有权系统管理内存__，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些
规则，程序都不能编译。在运行时，所有权系统的任何功能都 __不会__ 减慢程序。

跟踪哪部分代码正在使用 __堆__ 上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。


#### 所有权规则

1. Rust 中的每一个值都有一个 所有者（owner）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。


#### 变量作用域


Rust 采取的策略：内存在拥有它的变量离开作用域后就被自动释放。
当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop

- 注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 __资源获取即初始化__（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。

#### 变量与数据交互的方式（一）：移动


#### 变量与数据交互的方式（二）：克隆

- 只在栈上的数据：拷贝
    - 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。

### 所有权与函数


### 返回值与作用域

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

### 引用与借用

- &s

__引用__（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。

与使用 & 引用相反的操作是 __解引用__（dereferencing），它使用解引用运算符，*。

我们将创建一个引用的行为称为 __借用__（borrowing）。

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。


#### 可变引用

- &mut s

我们不能在同一时间多次将 s 作为可变变量借用。
这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。
这个限制的好处是 Rust 可以在编译时就避免数据竞争。
__数据竞争__（data race）类似于竞态条件，它可由这三个行为造成：

- 两个或更多指针同时访问同一数据。
- 至少有一个指针被用来写入数据。
- 没有同步数据访问的机制。

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

我们也 __不能__ 在拥有不可变引用的 __同时__ 拥有可变引用。


#### 悬垂引用（Dangling References）

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。

#### 引用的规则

- 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。
- 引用必须总是有效的。


#### Slice 类型

slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。



### 结构体


#### 通过派生 trait 增加实用功能

```rust
#[derive(Debug)]
    struct Rectangle {
    width: u32,
    height: u32,
}
```



#### 方法语法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}


```

```
在 C∕C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 −> 在一个对象的
指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 object 是一个指针，那
么 object−>something() 就像 (*object).something() 一样。
Rust 并没有一个与 −> 等效的运算符；相反，Rust 有一个叫 自动引用和解引用（automatic referencing
and dereferencing）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。
它是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &、&mut 或
* 以便使 object 与方法签名匹配。也就是说，这些代码是等价的：
```

每个结构体都允许拥有多个 impl 块。




### 枚举和模式匹配

#### 枚举的定义


#### 标准库定义的枚举类型

- IpAddr
- Option<T>


#### match 控制流结构


Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。

模式可由字面值、变量、通配符和许多其他内容构成

- 匹配 Option<T>
- 匹配是穷尽的
- 通配模式和 _ 占位符


#### if let 简洁控制流

以下两段代码等价
```rust
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
}

fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}
```
可以认为 if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。



### 使用包、Crate 和模块管理不断增长的项目

Rust 有许多功能可以让你管理代码的组织，包括哪些内容可以被公开，哪些内容作为私有部分，以及程序每个作用域中的名字。这些功能。这有时被称为 ” 模块系统（the module system）”，包括：

• 包（Packages）：Cargo 的一个功能，它允许你构建、测试和分享 crate。
• Crates ：一个模块的树形结构，它形成了库或二进制项目。
• 模块（Modules）和 use：允许你控制作用域和路径的私有性。
• 路径（path）：一个命名例如结构体、函数或模块等项的方式


#### 包和 Crate

crate 是 Rust 在编译时最小的代码单位。如果你用 rustc 而不是 cargo 来编译一个文件（第一章我们这么做过），编译器还是会将那个文件认作一个 crate。crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译

crate 有两种形式：二进制项和库。二进制项可以被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个 main 函数来定义当程序被执行的时候所需要做的事情。目前我们所创建的 crate都是二进制项。

库并没有 main 函数，它们也不会编译为可执行程序，它们提供一些诸如函数之类的东西，使其他项目也能使用这些东西。

crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块


包（package）是提供一系列功能的一个或者多个 crate。一个包会包含一个 Cargo.toml 文件，阐述如何去构建这些 crate。Cargo 就是一个包含构建你代码的二进制项的包。Cargo 也包含这些二进制项所依赖的库。其他项目也能用 Cargo 库来实现与 Cargo 命令行程序一样的逻辑。


包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。


Cargo 遵循的一个约定：src∕main.rs 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 src∕lib.rs，则包带有与其同名的库 crate，且 src∕lib.rs 是 crate 根。crate 根文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目。


#### 定义模块来控制作用域与私有性

• __从 crate 根节点开始__: 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是 src∕lib.rs，对于一个二进制 crate 而言是 src∕main.rs）中寻找需要被编译的代码。

• __声明模块__: 在 crate 根文件中，你可以声明一个新模块；比如，你用mod garden声明了一个叫做garden的模块。编译器会在下列路径中寻找模块代码：
    – 内联，在大括号中，当mod garden后方不是一个分号而是一个大括号
    – 在文件 src∕garden.rs
    – 在文件 src∕garden∕mod.rs

• __声明子模块__: 在除了 crate 根节点以外的其他文件中，你可以定义子模块。比如，你可能在src∕garden.rs 中定义了mod vegetables;。编译器会在以父模块命名的目录中寻找子模块代码：
    – 内联，在大括号中，当mod vegetables后方不是一个分号而是一个大括号
    – 在文件 src∕garden∕vegetables.rs
    – 在文件 src∕garden∕vegetables∕mod.rs

• __模块中的代码路径__: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的Asparagus类型可以在crate:: garden::vegetables::Asparagus被找到。

• __私有 vs 公用__: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用pub mod替代mod。为了使一个公用模块内部的成员公用，应当在声明前使用pub。

• __use 关键字__: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用crate:: garden::vegetables::Asparagus的作用域，你可以通过 use crate::garden::vegetables::Aspara建一个快捷方式，然后你就可以在作用域中只写Asparagus来使用该类型。

Rust 提供了将包分成多个 crate，将 crate 分成模块，以及通过指定绝对或相对路径从一个模块引用另一个模块中定义的项的方式。你可以通过使用 use 语句将路径引入作用域，这样在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加 pub 关键字使其定义变为公有。


### 常见集合

- vector 允许我们一个挨着一个地储存一系列数量可变的值
- 字符串（string）是字符的集合。
- 哈希 map（hash map）允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。




### 错误处理

Rust 将错误分为两大类：__可恢复的__（recoverable）和 __不可恢复的__（unrecoverable）错误。对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。


Rust 没有异常。相反，它有`Result<T, E>` 类型，用于处理可恢复的错误，还有 `panic!` 宏，在程序遇到不可恢复的错误时停止执行。

panic 时通过在 Cargo.toml 的 [profile ] 部分增加 panic = ’ abort’，可以由展开切换为终止。

#### 失败时 panic 的简写：unwrap 和 expect

`match` 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图。`Result<T, E>` 类型定义了很多辅助方法来处理各种情况。

如果 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。如果 `Result` 是成员 `Err`，`unwrap` 会为我们调用 `panic!`。



#### 传播错误

当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。


#### 传播错误的简写：? 运算符

`?` 运算符只能被用于返回值与 `?` 作用的值相兼容的函数。因为 `?` 运算符被定义为从函数中 __提早返回__ 一个值


#### 总结

Rust 的错误处理功能被设计为帮助你编写更加健壮的代码。panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 Result 来告诉代码调用者他需要处理潜在的成功或失败。在适当的场景使用 panic! 和 Result 将会使你的代码在面对不可避免的错误时显得更加可靠。




### 泛型、Trait 和生命周期

#### 泛型数据类型


#### Trait：定义共同行为

trait 定义了某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。




#### 生命周期

生命周期确保引用如预期一直有效。

Rust 中的每一个引用都有其 生命周期（lifetime），也就是 __引用保持有效的作用域__。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。



#### 借用检查器

Rust 编译器有一个 __借用检查器__（borrow checker），它比较作用域来确保所有的借用都是有效的。


#### 静态生命周期

'static，其生命周期能够存活于整个程序期间。



### 编写自动化测试

#### 测试的组织结构

- 单元测试
- 集成测试






### Rust 中的函数式语言功能：迭代器与闭包

__闭包__（Closures），一个可以储存在变量里的类似函数的结构
__迭代器__（Iterators），一种处理元素序列的方式




### Cargo 和 Crates.io



### 智能指针


__指针__（pointer）是一个包含内存地址的变量的通用概念。这个地址引用，或 ” 指向”（points at）一些其他数据。Rust 中最常见的指针是 __引用__（reference）。引用以 & 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能，也没有额外开销。


__智能指针__（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。Rust 标准库中定义了多种不同的智能指针，它们提供了多于引用的额外功能。

智能指针通常使用结构体实现。智能指针不同于结构体的地方在于其实现了 Deref 和 Drop trait。Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。


#### Box<T>，用于在堆上分配值


#### Rc<T>，一个引用计数类型，其数据可以有多个所有者

#### Ref<T> 和 RefMut<T>，通过 RefCell<T> 访问。（RefCell<T> 是一个在运行时而不是在编译时执行借用规则的类型）。



#### 引用循环与内存泄漏

Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 __内存泄漏__（memory leak）），但并不是不可能。与在编译时拒绝数据竞争不同，Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是 __内存安全__ 的。这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。



### 并发

__并发编程__（Concurrent programming），代表程序的不同部分相互独立的执行，而 __并行编程__（parallel programming）代表程序不同部分于同时执行，这两个概念随着计算机越来越多的利用多处理器的优势时显得愈发重要。由于历史原因，在此类上下文中编程一直是困难且容易出错的：Rust 希望能改变这一点。


起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全 和并发问题的强有力的工具！通过利用所有权和类型检查，在 Rust 中很多并发错误都是 编译时错误，而非运行时错误。因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。

- 如何创建线程来同时运行多段代码。
- 消息传递（Message passing）并发，其中信道（channel）被用来在线程间传递消息。
- 共享状态（Shared state）并发，其中多个线程可以访问同一片数据。
- Sync 和 Send trait，将 Rust 的并发保证扩展到用户定义的以及标准库提供的类型中。






### Rust 的面向对象特性




### 模式与模式匹配


__模式__（Patterns）是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 match 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符


#### 所有可能会用到模式的位置

- match 分支
- if let 条件表达式
- while let 条件循环
- for 循环
- let 语句
- 函数参数



#### Refutability（可反驳性）: 模式是否会匹配失效

模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 __不可反驳的__（irrefutable）。一个例子就是 let x = 5; 语句中的 x，因为 x 可以匹配任何值所以
不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 __可反驳的__（refutable）。一个这样的例子便是 if let Some(x) = a_value 表达式中的 Some(x)；如果变量 a_value 中的值是 None 而不是 Some，那么 Some(x) 模式不能匹配。



#### 所有的模式语法

- 匹配字面值
- 匹配命名变量
- 多个模式
    - 在 match 表达式中，可以使用 | 语法匹配多个模式，它代表 或（or）运算符模式。
- 通过 ..= 匹配值的范围
    - ..= 语法允许你匹配一个闭区间范围内的值。
- 解构并分解值
    - 可以使用模式来解构结构体、枚举和元组，以便使用这些值的不同部分。
- 忽略模式中的值
    - 使用 _ 忽略整个值
    - 使用嵌套的 _ 忽略部分值
    - 通过在名字前以一个 _ 开头来忽略未使用的变量
    - 用 .. 忽略剩余值
- 匹配守卫提供的额外条件
    - __匹配守卫__（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。
- @ 绑定
    - at 运算符（@）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。



### 高级特征

- 不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证
- 高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式
- 高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型
- 高级函数和闭包：函数指针和返回闭包
- 宏：定义在编译时定义更多代码的方式


### 实用开发工具

- 通过 rustfmt 自动格式化
- 通过 rustfix 修复代码
- 通过 clippy 提供更多 lint 功能
    - clippy 工具是一系列 lint 的集合，用于捕捉常见错误和改进 Rust 代码。
- 使用 rust-analyzer 的 IDE 集成















