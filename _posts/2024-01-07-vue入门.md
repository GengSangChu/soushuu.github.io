---
layout:     post
title:      vue入门
subtitle:   vue入门
date:       2024-01-07
author:     soushuuu
header-img: img/the-first.png
catalog: false
tags:
    - vue
---


    Vue 是一个前端的框架，主要负责帮助我们构建用户的界面
    MVVM：Model - View - View Model
    Vue 负责 vm 的工作（视图模型），通过 Vue 可以将视图和模型相关联。
    当模型发生变化时，视图会自动更新
    也可以通过视图去操作模型
    Vue 思想：
    组件化开发
    声明式的编程

#### 使用工具构建Vue

javascript包管理器一般有
- npm（node默认）
- yarn
- cnpm

安装vite工具
- yarn add -D vite  （安装vite工具）
- yarn create vite（用vite创建Vue项目）
    填写项目名称 hello_vue_1
    选择Vue
    选择JavaScript/TypeScript
- 运行项目
    - cd hello_vue_1
        yarn
        yarn dev
- 配置后端server
    ```ts
        server: {
            host: '0.0.0.0',
            port: 8991,
            // 是否开启 https
            https: false,
            open: false,
            strictPort: false,
            proxy: {
                '/api': {
                // target: 'http://localhost:8080/',
                target: '',
                changeOrigin: true,
                rewrite: path => path.replace(/^\/api/, '')
                }
            }
        },
    ```
#### template介绍

- template是用字符串的形式编写模板
    - 这些字符串会在项目运行时，在浏览器中被编译为js的函数（性能不太好）。
    - 在字符串中编写代码，体验很差。
- 为了解决这个问题，Vue为我们提供了一种单文件组件（SFC）
    - 单文件组件的格式是vue（vscode需要安装插件 Vue Language Features (Volar)）
    - vue文件用来编写单文件组件，vue文件本身并不能被浏览器所识别，所以它必须要被构建工具打包后才可使用。
    - 同时vue文件在打包时，构建工具会直接将template转换为函数，无需在浏览器中再去编译，这样一来性能也会有所提升。

#### App.vue根组件

- createApp(App) 将根组件关联到应用上，会返回一个应用的实例
- app.mount("#app") 将应用挂载到页面中
    - 会返回一个根组件的实例，组件的实例通常可以命名为vm
    - 组件实例是一个Proxy对象（代理对象）

组件，一个组件可以创建多个组件实例
组件就是一个普通的js对象

#### data详解

- data返回的对象最终会被Vue所代理。
- 建议将那些暂时没有使用到的属性，也添加到data返回的对象中，值可以设置为null。
- Vue在构建响应式对象时，会同时将对象中的属性也做成响应式属性，data默认使用深层响应式对象。
- 浅层响应式对象：通过shallowReactive()

    ```ts
    import {shallowReactive} from "vue"

    export default {
        data() {
            return shallowReactive({
                msg: "大闸蟹今天没去玩游戏！",
                stu: {
                    name: "孙悟空",
                    age: 18,
                    gender: "男",
                    friend: {
                        name: "猪八戒"
                    }
                }
            })
        }
    }
    ```

#### methods详解

- methods用来指定实例对象中的方法。
- 它是一个对象，可以在它里面定义多个方法
- 所定义的方法最终将会被挂载到组件实例上，可以直接通过组件实例来调用这些方法，所有组件实例上的属性都可以在模板中直接访问
- methods中函数的this会被自动绑定为组件实例

    ```ts
    export default {
        methods: {
            sum(a, b){
                return a + b
            }
        }
    }
    ```

#### 计算属性

- computed用来指定计算属性
- 计算属性只在其依赖的数据发生变化时才会重新执行
- 计算属性会对数据进行缓存
    ```ts
    export default {
        name: {
            // get只做读取相关的逻辑
            get() {
                return this.lastName + this.firstName
            },
            // set在计算属性被修改时调用
            set(value) {
                this.lastName = value[0]
                this.firstName = value.slice(1)
            }
        }
    }
    ```

#### 组合式API

- 在组合式API中直接声明的变量，就是一个普通的变量，不是响应式属性，修改这些属性时，不会在视图中产生效果。
- 可以通过reactive()来创建一个响应式的对象
- 在setup()中可以通过返回值来指定哪些内容要暴露给外部，暴露后的内容可以在模板中直接使用
    ```ts
    import { reactive } from "vue"

    export default {
        setup() {
            let msg = "今天天气真不错!"
            let count = 0

            const stu = reactive({
                name: "孙悟空",
                age: 18,
                gender: "男"
            })

            function changeAge(){
                stu.age = 44
            }

            return {
                msg,
                count,
                stu,
                changeAge
            }
        }
    }
    ```
- 可以在script标签上写上setup，即可使用组合式API
    ```ts
    <script setup>
        ......
    </script>
    ```

#### 响应式代理
- reactive()返回一个对象的响应式代理，同时也是一个深层响应式对象。
- shallowReactive()创建一个浅层响应式对象，但只能返回对象的响应式代理，不能处理原始值。
- ref()接收一个任意值，并返回它的响应式代理。
    - ref在生成响应式代理时，它是将值包装为了一个对象0 --> {value:0}。
    - 访问ref对象时，必须通过对象.value来访问其中的值。
    - 在模板中，ref对象会被自动解包，要求必须是顶层对象。

